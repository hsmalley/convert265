#!/bin/bash
set -o pipefail
IFS=$'\n\t'

pro_dir="/opt/amdgpu-pro/etc/vulkan/icd.d"
export LD_LIBRARY_PATH="/opt/amdgpu/libdrm/lib64:/opt/amdgpu/libdrm/lib32:$LD_LIBRARY_PATH"
export VK_ICD_FILENAMES="${pro_dir}/amd_icd32.json:${pro_dir}/amd_icd64.json:$VK_ICD_FILENAMES"

function get_subtitles() {
	# Try to get english subs if not then get all of them
	jq -r '.streams[] | select(.codec_type=="subtitle") | select(.tags.language | contains("en")) | .index' <"${video}.json" ||
		jq -r '.streams[] | select(.codec_type=="subtitle") | .index' <"${video}.json"
}

function getinfo() {
	if [[ ! -f "${video}.json" ]]; then
		ffprobe -v quiet -print_format json -show_streams "${video}" >"${video}.json"
	fi
	d=$(dirname "${video}")
	filename=$(basename "${video}")
	filename="${filename%.*}"
	video_codec=$(jq -r '.streams[0].codec_name' <"${video}.json")
	video_height=$(jq -r '.streams[0].height' <"${video}.json")
	sub_indexes=$(get_subtitles)
	video_size=$(stat -c%s "${video}")
	video_size_50=$((video_size * 50 / 100))
	_filename=$(echo "${filename}" | sed -e 's/h264/x265/g' -e 's/x264/x265/g' -e 's/AVC/x265/g' -e 's/XviD/x265/g')
	echo -e "${video} // ${video_codec} // ${video_height} // ${video_size}"
}

function extract_subtitles() {
	for subtitle in ${sub_indexes}; do
		nice -n 18 ffmpeg -hide_banner -loglevel error -n -threads 4 -i "${video}" -map "0:${subtitle}" "${video}_${subtitle}.srt"
	done
}

function convert_video_memory() {
	nice -n 19 ffmpeg -hide_banner -loglevel info -y -threads 4 -hwaccel vaapi -hwaccel_output_format vaapi -vaapi_device /dev/dri/renderD128 -analyzeduration 20000000 -probesize 20000000 \
		-i "${video}" -map 0:v -map 0:a -map 0:s? -map 0:d? -map 0:t? -c:s copy -c:a copy \
		-vf 'scale_vaapi=format=p010,scale_vaapi=w=1920:-2' -c:v hevc_vaapi -profile:v main10 \
		-max_muxing_queue_size 1024 -movflags +faststart -movflags use_metadata_tags "/dev/shm/${_filename}.mkv" || exit 1
	mv -vu "/dev/shm/${_filename}" "${d}/${_filename}" || rm -f "/dev/shm/${_filename}.mkv"
	file_size=$(stat -c%s "${d}/${_filename}.mp4")
	if ((file_size >= video_size_50)); then
		cleanup
	fi
}

function convert_video_audio_problems() {
	nice -n 19 ffmpeg -hide_banner -loglevel info -y -threads 4 -hwaccel vaapi -hwaccel_output_format vaapi -vaapi_device /dev/dri/renderD128 -analyzeduration 20000000 -probesize 20000000 \
		-i "${video}" -map 0:v -map 0:a -map 0:s? -map 0:d? -map 0:t? -c:s copy \
		-c:a libopus -b:a 128k -vbr on -compression_level 10 -frame_duration 60 -application audio -mapping_family 1 -ac 2 \
		-vf 'scale_vaapi=format=p010,scale_vaapi=w=1920:-2' -c:v hevc_vaapi -profile:v main10 \
		-max_muxing_queue_size 1024 -movflags +faststart -movflags use_metadata_tags "${d}/${_filename}.mkv" || exit 1
	file_size=$(stat -c%s "${d}/${_filename}.mp4")
	if ((file_size >= video_size_50)); then
		cleanup
	fi
}

function convert_video() {
	nice -n 19 ffmpeg -hide_banner -loglevel info -y -threads 4 -hwaccel vaapi -hwaccel_output_format vaapi -vaapi_device /dev/dri/renderD128 -analyzeduration 20000000 -probesize 20000000 \
		-i "${video}" -map 0:v -map 0:a -map 0:s? -map 0:d? -map 0:t? -c:s copy -c:a copy \
		-vf 'scale_vaapi=format=p010,scale_vaapi=w=1920:-2' -c:v hevc_vaapi -profile:v main10 \
		-max_muxing_queue_size 1024 -movflags +faststart -movflags use_metadata_tags "${d}/${_filename}.mkv" || exit 1
	file_size=$(stat -c%s "${d}/${_filename}.mp4")
	if ((file_size >= video_size_50)); then
		cleanup
	fi
}

function convert_video_qsv_memory() {
		nice -n 19 ~/Downloads/ffmpeg/ffmpeg -hide_banner -loglevel quiet -y -threads 4 -hwaccel qsv -hwaccel_output_format qsv -analyzeduration 20000000 -probesize 20000000 \
			-i "${video}" -map 0:v:0 -map 0:a -map 0:s? -map 0:d? -map 0:t? -c:s copy -c:a copy \
			-c:v hevc_qsv -low_power false -preset 4 -profile:v 1 -scenario 3 -look_ahead 1 -global_quality 20 \
      -max_muxing_queue_size 1024 -movflags +faststart -movflags use_metadata_tags "/dev/shm/${_filename}.mkv" || exit 1
	mv -vu "/dev/shm/${_filename}" "${d}/${_filename}" || rm -f "/dev/shm/${_filename}.mkv"
	file_size=$(stat -c%s "${d}/${_filename}.mp4")
	if ((file_size >= video_size_50)); then
		cleanup
	fi
}

function convert_video_qsv() {
		nice -n 19 ~/Downloads/ffmpeg/ffmpeg -hide_banner -loglevel quiet -y -threads 4 -hwaccel qsv -hwaccel_output_format qsv -analyzeduration 20000000 -probesize 20000000 \
			-i "${video}" -map 0:v:0 -map 0:a -map 0:s? -map 0:d? -map 0:t? -c:s copy -c:a copy \
			-c:v hevc_qsv -low_power false -preset 4 -profile:v 1 -scenario 3 -look_ahead 1 -global_quality 20 \
			-max_muxing_queue_size 1024 -movflags +faststart -movflags use_metadata_tags "${d}/$_filename.mkv" || exit 1
	file_size=$(stat -c%s "${d}/${_filename}.mp4")
	if ((file_size >= video_size_50)); then
		cleanup
	fi
}

function remux_video() {
	extract_subtitles
	ffmpeg -hide_banner -loglevel info -y -threads 4 -i "${video}" -c: copy -movflags +faststart -movflags use_metadata_tags "${d}/${_filename}.mp4" || exit 1
	find "${d}" -size 0 -delete
	file_size=$(stat -c%s "${d}/${_filename}.mp4")
	if ((file_size >= video_size)); then
		cleanup
	fi
}

function cleanup() {
	find "${d}" -size 0 -delete
	rm -vf "${video}" "${video}.json"
}

for video; do
	getinfo
	if [[ ${video_codec} =~ "av1" ]]; then
		exit
	fi
	if [[ ! ${video_codec} =~ "hevc" || ${video_height} -gt 1080 ]]; then
		convert_video_qsv
	fi
done
